---
title: 状态转移方程中的状态究竟是指什么？
date: 2023-08-08 17:10:05
tags: 
categories:
  - - 算法
auto_excerpt: "true"
---

都怪你起了个奇怪的名字，让我们难以理解。

首先我们搞明白状态的定义。状态在不同的学科具有不同的含义，而在算法中，这个状态实际上是指某事物在某一特定时刻的快照。具体而言，此快照内包含了所有描述这个事物的具体信息，就像某数据结构的对象定义了很多成员变量，在某一时刻，我们抄下这个对象中的所有成员变量的值，就像对这个对象做了一次“快照”，快照可以完全描述这个对象在该时刻的状态，就像一张真正的照片一样。

既然状态是指快照，那么状态转移就是“快照转移”的同义词，“快照转移”和算法又有什么关联呢？这要从动态规划的使用条件上追究，一个问题如果能用动态规划解决，有的书上一般说需要满足两个使用条件，第一个是重叠子问题，第二个是最优子结构，而其实，其中核心之处是“重叠子问题”，“最优子结构”其实不完全需要（后文会讨论这一点）。

那么什么是“重叠子问题”呢？重叠子问题是指一个问题，可以被分解为更多更小的问题的解，通过求出所有更小的解可以求出我们想要的大问题的解，而且这些更小的问题是存在重复问题的，即“重叠”。

以求斐波那契数列问题为例，我们需要解决的大问题，是求出f(n)，而按照斐波那契数列的定义（兼状态转移方程）f(n) = f(n-1) + f(n-2)，想要求出f(n)，我们需要解决的问题是求出f(n-1) + f(n-2)的值，即求出两个子问题f(n-1) 和f(n-2)。此时观察f(n-1)，其由f(n-2)+f(n-3)求到值；观察f(n-2)，其由f(n-3)+f(n-4)求到值。我们会发现我们把求f(n)问题分解成为求f(n-1)和f(n-2)问题之后，f(n-1)和f(n-2)本身也分别需要接着求出值，然后原方程变为f(n) = (f(n-2)-f(n-3)) + f(n-3)+f(n-4)，注意此时“重叠子问题”的“重叠”之处已经出现了，f(n-3)问题出现了两次。

以此类推，每把子问题推进一层，子问题又由子问题构成，而完整的求解过程，会反复用到很多重复的子问题，按理来说动态规划要原原本本老实每次都重复计算一次，将是非常消耗算力的，即计算量很庞大，所以动态规划中还有一个高频的词汇叫“记忆化搜索”，把这些子问题的解记录下来，就不用重复计算了，每次查表就能获得该问题的解，节省了算力。

记忆化搜索是题外话，我们需要解决问题，算力不是最重要的，核心是我们要解决问题，能够做到求出解。再观察上述斐波那契数列的求解过程，我们之所以能够最终求到解，原理其实是因为把大问题分解成了与大问题类似但问题规模更小的子问题，解决过斐波那契数列问题的同学肯定知道，最终我们会把问题规模缩小到2=1+1，虽然不知道2是“f(n-几)”的解，但是我们把问题规模一直缩小到了一个已知的问题，即教科书上常说的“把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了”。

铺垫了很久，还记得我们之前说的动态就是“快照”的意思吗？求解斐波那契数列的过程，其中每一个f(n)的解的值，都是对这个问题的一次快照。具体而言，在使用状态转移方程解决问题时，我们把问题视作从最小规模开始逐步演进的一系列快照，这些快照即状态，每一个状态代表了问题在某一特定阶段的答案，这些状态是动态的，状态们根据一定的规则相互转移，因而问题从我们能够轻易求解到的、已知的或简单的基础的最小规模问题（斐波那契数列中的2=1+1），一路通过一定的规则，变成一个问题规模很大的问题（要求解的f(n)）。即把问题的求解看做同一个事物在不断地发展和演进，而每一个解都视为“问题”这一事物在某一瞬间的一个快照，快照（解）们不断转移，我们最终抓住它转移到n的那一瞬间，获得f(n)的快照，于是得到了f(n)的解，这是动态规划能够解决这类问题的原理，也是为什么状态转移要叫状态转移，其实是把要求的原问题的解视作快照演进过程中的某一个瞬间。

因此，重叠子问题对动态规划是不可或缺的，不仅要重叠（让我们能够把解们记录下来，减少求解的运算量），而且这些子问题和原问题还要“形式相同或相似”，这样就能层层“递归”，我们只需要知道一个最小最基本规模问题的解，就能一路把快照演进上去，求到原问题的快照（解）。而最优子结构指的是“一个问题的最优解包含其子问题的最优解”，即问题的最优解是从其子问题的最优解中构造而来。显然这是对最优类问题如果想使用动态规划求解所提出的要求，例如背包问题。斐波那契数列问题就不是一个最优问题，却也一样可以用动态规划求解，不是吗？

显然，写出状态转移方程的关键在于找到状态之间的演进规律，找到当前问题的解是根据什么规律不断从更小规模的问题转移而来。